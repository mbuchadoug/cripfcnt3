// utils/autoFetchAndScore.js
import { TavilyClient } from "tavily";
import fs from "fs";
import path from "path";

const tavily = new TavilyClient({
  apiKey: process.env.TAVILY_API_KEY || "your_tavily_key_here",
});

// ----------------------
// ðŸ”¹ Load CRIPFCnt Logic
// ----------------------
const logicPath = path.join(process.cwd(), "data", "cripfcnt.txt");
let cripfLogic = "";
try {
  cripfLogic = fs.readFileSync(logicPath, "utf8");
  console.log("âœ… Loaded CRIPFCnt logic from data/cripfcnt.txt");
} catch (err) {
  console.warn("âš ï¸ Could not read cripfcnt.txt:", err.message);
}

// ----------------------
// ðŸ”¹ Setup Cache
// ----------------------
const cachePath = path.join(process.cwd(), "data", "cache.json");
if (!fs.existsSync(cachePath)) fs.writeFileSync(cachePath, "{}");
let cache = {};
try {
  cache = JSON.parse(fs.readFileSync(cachePath, "utf8") || "{}");
} catch {
  cache = {};
}

/**
 * Generate SCOI-style audit using CRIPFCnt methodology
 * Deterministic + Framework-anchored version
 */
export default async function autoFetchAndScore(entity, openai) {
  console.log(`ðŸ” Running CRIPFCnt SCOI audit for: ${entity}`);

  // âœ… Return from cache if already analyzed
  if (cache[entity]) {
    console.log(`âš¡ Returning cached SCOI for ${entity}`);
    return cache[entity];
  }

  // ----------------------
  // ðŸ”¹ Fetch context
  // ----------------------
  let tavilyResults;
  try {
    tavilyResults = await tavily.search({
      query: entity,
      search_depth: "advanced",
      max_results: 5,
    });
  } catch (error) {
    console.error("âŒ Tavily fetch failed:", error.message);
  }

  const webText =
    tavilyResults?.results
      ?.map((r) => `${r.title}\n${r.snippet}`)
      .join("\n\n") || "No search results available.";

  // ----------------------
  // ðŸ”¹ AI Prompt (Anchored)
  // ----------------------
  const aiPrompt = `
You are the official CRIPFCnt SCOI computation model (Donald Mataranyika Axis Framework).

Below is your full internal logic and scoring methodology:
---
${cripfLogic}
---

ðŸŽ¯ Task:
Perform a CRIPFCnt SCOI Audit for: "${entity}"

Always follow this 6-step structure:
1ï¸âƒ£ Visibility â€” score (0â€“10) and rationale  
2ï¸âƒ£ Contribution â€” score (0â€“10) and rationale  
3ï¸âƒ£ SCOI Calculation (show formula + interpretation)  
4ï¸âƒ£ Global Environment Adjustment â€” ERF and rationale  
5ï¸âƒ£ Adjusted SCOI (show full equation)  
6ï¸âƒ£ Final CRIPFCnt Commentary â€” with civilization tone and structural depth  

ðŸ§­ Rules:
- Use the CRIPFCnt logic, weights, and ERF definitions above.
- Reference the examples in the framework file for tone and interpretation.
- Be consistent across runs (no randomness).
- Align numbers with the proportionality shown in the framework.
- Incorporate the global environment stress context.

Context for this audit:
${webText}
`;

  // ----------------------
  // ðŸ”¹ Generate AI Response
  // ----------------------
  const response = await openai.responses.create({
    model: "gpt-4o-mini",
    input: aiPrompt,
  });

  const summary =
    response.output?.[0]?.content?.[0]?.text ||
    "No summary generated by CRIPFCnt auditor.";

  // ----------------------
  // ðŸ”¹ Parse key numbers
  // ----------------------
  const num = (label) => {
    const m = summary.match(
      new RegExp(`${label}[^\\d]*(\\d+(\\.\\d+)?)`, "i")
    );
    return m ? parseFloat(m[1]) : null;
  };

  const visibility = num("Visibility") || 8.5;
  const contribution = num("Contribution") || 7.5;
  const erf = num("ERF") || 1.1;
  const rawSCOI = +(contribution / visibility).toFixed(2);
  const adjustedSCOI = +(rawSCOI * erf).toFixed(2);

  // Placement classification
  let placementLevel =
    adjustedSCOI > 1.0
      ? "Silent Over-Contributor"
      : adjustedSCOI >= 0.95
      ? "Balanced Axis"
      : "Grid Performer";

  // Extract main text sections
  const interpretation = extractSection(summary, "Interpretation");
  const commentary = extractSection(summary, "Commentary");

  // ----------------------
  // ðŸ”¹ Add depth & structure
  // ----------------------
  const structuralInsight = `
ðŸ“˜ Structural Insight:
This audit reflects ${entity}'s position within the CRIPFCnt Axis Law â€”
where Visibility, Responsibility, and Resilience define placement under civilization stress.
The Adjusted SCOI of ${adjustedSCOI} situates it as a "${placementLevel}" within the Recalibration Spectrum.
`;

  // ----------------------
  // ðŸ”¹ Build final object
  // ----------------------
  const result = {
    entity,
    visibility,
    contribution,
    rawSCOI,
    adjustmentFactor: erf,
    adjustedSCOI,
    placementLevel,
    summary: summary.trim(),
    interpretation,
    commentary: `${commentary}\n\n${structuralInsight}`.trim(),
    urls: tavilyResults?.results?.map((r) => r.url) || [],
    source: "tavily + CRIPFCnt logic",
  };

  // ----------------------
  // ðŸ”¹ Cache for future use
  // ----------------------
  cache[entity] = result;
  fs.writeFileSync(cachePath, JSON.stringify(cache, null, 2));

  return result;
}

/**
 * Extract specific section text from the AI summary
 */
function extractSection(text, keyword) {
  const re = new RegExp(`${keyword}[:\\-\\s]+([\\s\\S]*?)(?=\\n\\d|$)`, "i");
  const m = text.match(re);
  return m ? m[1].trim() : "";
}
