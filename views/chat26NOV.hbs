<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>{{title}}</title>
  <title>CRIPFCnt ‚Äî A Recalibration of Intelligence & Society</title>
<meta name="description" content="CRIPFCnt ‚Äî a framework by Donald Mataranyika for recalibrating society and intelligence. Explore SCOI audits, the CRIPFCnt life manual, leadership tools, and the book 'CRIPFCnt: Taking Psychology to the People'." />
<link rel="canonical" href="{{siteUrl}}{{canonicalPath}}" />

<!-- Open Graph -->
<meta property="og:site_name" content="CRIPFCnt" />
<meta property="og:type" content="website" />
<meta property="og:title" content="CRIPFCnt ‚Äî Recalibrating Intelligence & Society" />
<meta property="og:description" content="CRIPFCnt by Donald Mataranyika: an eight-pillar framework and life manual redefining consciousness, responsibility and interpretation for the AI age." />
<meta property="og:url" content="{{siteUrl}}{{canonicalPath}}" />
<meta property="og:image" content="{{siteUrl}}/static/img/logo.png" />
<meta property="og:image:alt" content="CRIPFCnt ‚Äî Donald Mataranyika" />

<!-- Twitter -->
<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:title" content="CRIPFCnt ‚Äî Recalibrating Intelligence & Society" />
<meta name="twitter:description" content="CRIPFCnt ‚Äî an eight-pillar framework and life manual for society, leadership and AI-era intelligence." />
<meta name="twitter:image" content="{{siteUrl}}/static/img/logo.png" />

<!-- Structured Data: Organization + WebSite (trimmed) -->
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "Organization",
  "name": "CRIPFCnt",
  "url": "{{siteUrl}}",
  "logo": "{{siteUrl}}/static/img/logo.png"
}
</script>

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "WebSite",
  "url": "{{siteUrl}}",
  "potentialAction": {
    "@type": "SearchAction",
    "target": "{{siteUrl}}/search?q={search_term_string}",
    "query-input": "required name=search_term_string"
  }
}
</script>

  <style>
    body { font-family: Arial, sans-serif; margin: 40px; background: #f5f7fa; }
    header{display:flex;justify-content:space-between;align-items:center;margin-bottom:22px;}
    h1{color:#003366;font-weight:800;margin:0;}
    p{font-size:1rem;color:#333;margin:6px 0 0 0;}
    input,button{padding:8px;margin:4px 0;font-size:1rem;}
    button{background:#0066cc;color:#fff;border:none;border-radius:4px;cursor:pointer;transition:0.2s}
    button:hover{background:#004c99}
    #output{background:#f9fafb;border-radius:12px;padding:1.5rem;font-family:"Inter",sans-serif;font-size:15px;color:#222;line-height:1.7;max-height:75vh;overflow-y:auto}
    .loader{display:inline-block;width:50px;height:50px;border:4px solid #e0e0e0;border-top:4px solid #0066cc;border-radius:50%;animation:spin 1s linear infinite;margin-top:15px}
    @keyframes spin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}
    .loading-text{font-size:1rem;color:#003366;margin-top:10px;font-weight:600;letter-spacing:0.5px}
    .section{margin-bottom:1.6rem}
    .section-header{color:#003366;font-weight:700;font-size:15px;margin-bottom:0.4rem}
    .divider{border-top:1px solid #e0e0e0;margin:1.2rem 0}
    .user-block{display:flex;align-items:center;gap:12px;font-size:0.95rem;color:#222}
    .user-block img{width:44px;height:44px;border-radius:50%;object-fit:cover;border:2px solid #e6eef8}
    .user-meta{text-align:right}
    .user-meta .name{font-weight:700;color:#003366}
    .user-meta .email{font-size:0.85rem;color:#666}
    .user-actions a{display:inline-block;margin-left:12px;padding:6px 10px;background:#fff;border:1px solid #d9e6fb;color:#003366;text-decoration:none;border-radius:8px;font-weight:600}
    @media (max-width:680px){body{margin:16px}.user-block img{width:36px;height:36px}}
    /* Note style */
    .note { background:#fff; border-left:4px solid #ffd54f; padding:12px 16px; border-radius:8px; margin-top:12px; color:#333; }
    .note .title { font-weight:700; color:#333; margin-bottom:6px; }
    .note small { color:#555; }
  </style>
</head>
<body>
  <header>
    <div>
      <h1>{{title}}</h1>
      <p>{{message}}</p>
    </div>

    {{#if user}}
      <div class="user-block" aria-live="polite">
        <img src="{{user.photo}}" alt="avatar" onerror="this.style.display='none'">
        <div class="user-meta">
          <div class="name">{{user.firstName}}{{#if user.lastName}} {{user.lastName}}{{/if}}</div>
          <div class="email">{{user.email}}</div>
        </div>
        <div class="user-actions">
          <a href="/auth/logout" title="Sign out">Sign out</a>
        </div>
      </div>
    {{/if}}
  </header>

  <div style="margin-bottom:18px;">
    <input id="entity" type="text" placeholder="Enter a company, person, theory, law, term, biography (e.g., Lafarge; Isaac Newton; Rationale; Fourier Transform)" style="width:75%; max-width:760px;">
    <button id="analyzeBtn">Analyze</button>
  </div>

  <div id="output"></div>

  <script>
    // small helper: escape HTML
    function escapeHtml(s){
      if(!s) return "";
      return String(s)
        .replace(/&/g,'&amp;')
        .replace(/</g,'&lt;')
        .replace(/>/g,'&gt;')
        .replace(/"/g,'&quot;')
        .replace(/'/g,'&#039;');
    }

    // build regex that matches spaced-out letters for an entity (supports punctuation and short names)
    function entitySpacedRegex(entity) {
      if (!entity) return null;
      // keep letters/numbers only for pattern building, but keep original entity for replacement
      const core = String(entity).replace(/\s+/g, "").replace(/[^a-zA-Z0-9]/g, "");
      if (!core) return null;
      // if core is short (<=2 char) match whole word only
      if (core.length <= 2) {
        return new RegExp("\\b" + core.split("").map(ch => ch.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&") + "\\s*").join("") + "\\b", "gi");
      }
      // create pattern like: L\s*a\s*f\s*a\s*r\s*g\s*e (works for spaced letters)
      const pattern = core.split("").map(ch => ch.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&") + "\\s*").join("");
      return new RegExp(pattern, "gi");
    }

    // conservative cleaning of streamed text (keeps punctuation, avoids over-joining)
    function conservativeClean(text) {
      if (!text) return "";

      let s = String(text);

      // remove SSE markers
      s = s.replace(/data:\s*/g, "").replace(/\[DONE\]/g, "");

      // collapse multiple whitespace to a single space
      s = s.replace(/\s+/g, " ").trim();

      // fix broken decimals (e.g. "0 . 875")
      s = s.replace(/(\d)\s*\.\s*(\d)/g, "$1.$2");

      // normalize SCOI / ERF broken spacing
      s = s.replace(/\bSCO\s*I\b/gi, "SCOI");
      s = s.replace(/\bER\s*F\b/gi, "ERF");

      // fix spaced letters for common tokens like SCOI and CRIPFCnt
      s = s.replace(/\bS\s*C\s*O\s*I\b/gi, "SCOI");
      s = s.replace(/\bC\s*R\s*I\s*P\s*F\s*C\s*n\s*t\b/gi, "CRIPFCnt");
      s = s.replace(/\bC\s*R\s*I\s*P\s*F\s*C\s*N\s*T\b/gi, "CRIPFCnt");

      return s;
    }

    document.getElementById('analyzeBtn').addEventListener('click', startChat);
    document.getElementById('entity').addEventListener('keypress', (e) => {
      if (e.key === 'Enter') startChat();
    });

    async function startChat() {
      const entityInput = document.getElementById("entity");
      const entityRaw = entityInput.value || "";
      const entity = entityRaw.trim();
      if (!entity) return alert("Please enter an entity, person, theory, term or short phrase to analyze.");

      // Limit extremely long inputs to prevent accidental overload (you can change length)
      if (entity.length > 800) {
        return alert("Please shorten the query to under 800 characters.");
      }

      const output = document.getElementById("output");
      output.innerHTML = `
        <b>üîç SCOI Audit ‚Äî ${escapeHtml(entity)}</b><br><br>
        <div class="loader" role="status" aria-hidden="true"></div>
        <div class="loading-text">Analyzing "${escapeHtml(entity)}" ‚Äî this may take a few seconds...</div>
      `;

      try {
        const res = await fetch("/api/chat-stream", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          // send the entity as-is; server should accept arbitrary strings (company, person, theory, term)
          body: JSON.stringify({ entity })
        });
        if (!res.ok) {
          // surface server error
          const errText = await res.text().catch(()=>null);
          throw new Error("Server error: " + (errText || res.status + " " + res.statusText));
        }
        if (!res.body) throw new Error("No response stream from server.");

        const reader = res.body.getReader();
        const decoder = new TextDecoder();
        let fullText = "";
        let done = false;

        // Read stream; ensure we don't accidentally join tokens across chunk boundaries
        while (!done) {
          const { value, done: d } = await reader.read();
          done = d;
          if (value) {
            const chunk = decoder.decode(value, { stream: !done });
            // Avoid accidental joining of alphanumeric tokens across chunk boundary
            if (fullText.length > 0 && /[A-Za-z0-9]$/.test(fullText) && /^[A-Za-z0-9]/.test(chunk)) {
              fullText += " " + chunk;
            } else {
              fullText += chunk;
            }
          }
        }

        // conservative clean the whole payload
        let cleaned = conservativeClean(fullText);

        // 1) Replace spaced-out forms of the user-entered entity with the canonical user entry
        const entRegex = entitySpacedRegex(entity);
        if (entRegex) cleaned = cleaned.replace(entRegex, entity);

        // 2) Some safe canonical tokens (optional, not mandatory) ‚Äî keep for nicer output
        const canonical = {
          "lafarge": "Lafarge",
          "innscor": "Innscor",
          "zimplats": "Zimplats",
          "econet": "Econet",
          "nyaradzo": "Nyaradzo",
          "natfood": "Natfood",
          "cbz": "CBZ",
          "cafca": "Cafca",
          "zimsec": "ZIMSEC"
        };

        Object.keys(canonical).forEach(k => {
          const v = canonical[k];
          const spacedPattern = k.split("").map(ch => ch.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&") + "\\s*").join("");
          cleaned = cleaned.replace(new RegExp(spacedPattern, "gi"), v);
        });

        // Ensure tokens are separated from adjacent words (avoid "Lafargehas")
        const canonValues = Object.values(canonical).map(v => v.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&")).join("|");
        if (canonValues) {
          cleaned = cleaned.replace(new RegExp(`(${canonValues})(?=[A-Za-z0-9])`, "gi"), "$1 ");
          cleaned = cleaned.replace(new RegExp(`(?<=[A-Za-z0-9])(${canonValues})`, "gi"), " $1");
          cleaned = cleaned.replace(/\s{2,}/g, " ").trim();
        }

        // final CRIPFCnt fix
        cleaned = cleaned.replace(/\bC\s*R\s*I\s*P\s*F\s*C\s*n\s*t\b/gi, "CRIPFCnt");

        // split into sections (graceful fallback if model doesn't use numeric markers)
        const sections = cleaned.split(/\n{2,}|(?=\d+\s*[Ô∏è‚É£]\s*)/).map(s => s.trim()).filter(Boolean);

        // Render sections with headers if possible
        let formatted = sections.map(sec => {
          // try extract a short header (numbers, or first 6-12 words)
          const firstLine = sec.split("\n", 1)[0] || "";
          const headerMatch = firstLine.match(/^(\d{1,2}\b[^\n:]{0,40}|[A-Z][^.\n]{0,60})/);
          const header = headerMatch ? headerMatch[0] : "Section";
          const body = sec.replace(header, "").trim();
          return `
            <div class="section">
              <div class="section-header">${escapeHtml(header)}</div>
              <div>${escapeHtml(body)}</div>
            </div>
            <div class="divider"></div>
          `;
        }).join("");

        // Highlight a few key tokens for readability
        formatted = formatted
          .replace(/(\d+(\.\d+)?\s*[√ó\/]\s*\d+(\.\d+)?)/g, "<b>$1</b>")
          .replace(/\b(SCOI\s*=?\s*[\d.]+)/gi, "<b style='color:#004c99;'>$1</b>")
          .replace(/\b(ERF\s*=?\s*[\d.]+)/gi, "<b style='color:#006600;'>$1</b>")
          .replace(/\b(Visibility|Contribution|Adjustment|Commentary|Environment|Calculation|Rationale|Score)\b/gi, "<b style='color:#003366;'>$1</b>");

        // final note
        const note = `
          <div class="section note">
            <div class="title">üìå Note</div>
            <div>
              <small>This output is directly from the SCOI/CRIPFCnt model for the supplied entity. For a formal recalibration or research-grade audit, contact CRIPFCnt Research Desk.</small>
            </div>
          </div>
        `;

        output.innerHTML = `<div><strong>Results for:</strong> ${escapeHtml(entity)}</div><br>` + (formatted || "<div>No detailed sections were produced ‚Äî the model returned a short summary.</div>") + note;

      } catch (err) {
        output.innerHTML = `‚ùå Error: ${escapeHtml(err.message || String(err))}`;
      }
    }
  </script>
</body>
</html>
